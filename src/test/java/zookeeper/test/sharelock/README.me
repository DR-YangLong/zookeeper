## 共享锁
数据库锁概念：
> S锁：读锁，事务T持有对象A的S锁，则只能对A进行读操作而不能进行其他操作，此时其他事务可以再对A加锁，但只能是S锁，
直到A上的S锁全部释放，才能加其他锁。

> X锁：排它锁，事务T持有对象A的X锁，可以对A进行完全操作，此时其他任何事务不能对A加任何类型的锁。

## ZK实现共享锁
利用zk的顺序节点，规定创建时顺序标识最小的节点数获得锁。

* 场景：多个服务器操作同一资源，有的加S锁读数据，有的X锁写或改数据。
* 基本思路：

> 每个服务器通过自己的标识，以服务器名称为例，向zk同一节点下创建临时顺序子节点，同时在此节点上添加watcher监听子节点变化，
当节点变化后，获取数据，**用自己的标识**判断顺序节点中最小的那个是不是自己创建的，如果是，说明此时自己获得锁，可以对资源进行操作。

* 读写锁控制：
在创建节点前，通过watcher获得的数据判断此时顺序节点中锁的类型，并根据自己要加锁的类型进行判断是否可以加锁

> 此时自己要S锁：1.顺序节点中全是S锁节点，加锁，并进行操作，此时为共享锁。2.节点中有X锁节点，加锁，并挂起，
等待本节点之前所有X锁节点删除后，再进行操作。

> 此时自己要加X锁：加锁，挂起，等待之前的锁节点删除后在进行操作。

本例流程：
* 每个线程用当前时间做为服务器标识。
* 约定节点创建锁节点的父目录为 /sourcelock/sharelock，此目录需要新建。
* 约定资源数量节点：/sourcelock/sourcenum 值为资源数，此节点需要新建。
* 约定顺序锁节点名称前缀为：[锁类型][服务器名称]-[zk自动生成的序列号]

S锁读取资源数，X锁资源数减一。